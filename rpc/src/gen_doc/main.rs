//! this is a tool to generate rpc doc
mod utils;
use crate::utils::*;
use ckb_rpc::module::*;
use serde_json::Value;
use std::fs;

fn dump_openrpc_json() -> Result<(), Box<dyn std::error::Error>> {
    let dir = "./target/doc/ckb_rpc_openrpc/";
    fs::create_dir_all(dir)?;
    let dump = |name: &str, doc: serde_json::Value| -> Result<(), Box<dyn std::error::Error>> {
        fs::write(dir.to_owned() + name, doc.to_string())?;
        Ok(())
    };
    dump("alert_rpc_doc.json", alert_rpc_doc())?;
    dump("net_rpc_doc.json", net_rpc_doc())?;
    dump("subscription_rpc_doc.json", subscription_rpc_doc())?;
    dump("debug_rpc_doc.json", debug_rpc_doc())?;
    dump("chain_rpc_doc.json", chain_rpc_doc())?;
    dump("miner_rpc_doc.json", miner_rpc_doc())?;
    dump("pool_rpc_doc.json", pool_rpc_doc())?;
    dump("stats_rpc_doc.json", stats_rpc_doc())?;
    dump("integration_test_rpc_doc.json", integration_test_rpc_doc())?;
    dump("indexer_rpc_doc.json", indexer_rpc_doc())?;
    dump("experiment_rpc_doc.json", experiment_rpc_doc())?;
    eprintln!("dump openrpc json...");
    Ok(())
}

fn gen_rpc_readme(readme_path: &str) -> Result<(), Box<dyn std::error::Error>> {
    let all_rpc = vec![
        alert_rpc_doc(),
        net_rpc_doc(),
        subscription_rpc_doc(),
        debug_rpc_doc(),
        chain_rpc_doc(),
        miner_rpc_doc(),
        pool_rpc_doc(),
        stats_rpc_doc(),
        integration_test_rpc_doc(),
        indexer_rpc_doc(),
        experiment_rpc_doc(),
    ];
    let mut rpc_module_methods = vec![];
    for rpc in all_rpc {
        if let serde_json::Value::Object(map) = rpc {
            let module_title = map["info"]["title"].as_str().unwrap();
            // strip `_rpc` suffix
            let module_title = &module_title[..module_title.len() - 4];
            let module_methods = map["methods"].as_array().unwrap();
            let types = map["components"]["schemas"].as_object().unwrap();
            rpc_module_methods.push(RpcModule {
                module_title: module_title.to_owned(),
                module_methods: module_methods.to_owned(),
                types: types.to_owned(),
            });
        }
    }

    // sort rpc_module_methods accoring to module_title
    rpc_module_methods.sort_by(|a, b| a.module_title.cmp(&b.module_title));

    let mut res = String::new();

    // strip lines below `**NOTE:**`
    let readme = fs::read_to_string(readme_path).unwrap_or("".to_owned());
    let lines = readme.lines().collect::<Vec<_>>();
    for &line in lines.iter() {
        res.push_str(&(line.to_owned() + "\n"));
        if line.contains("**NOTE:** the content below is generated by gen_doc") {
            break;
        }
    }

    let mut types: Vec<(String, &Value)> = vec![];
    for rpc_module in rpc_module_methods.iter() {
        for (name, ty) in rpc_module.types.iter() {
            if !types.iter().any(|(n, _)| *n == *name) {
                types.push((name.to_owned(), ty));
            }
        }
    }

    // generate methods menu
    res.push_str("\n\n* [RPC Methods](#rpc-methods)\n");
    for rpc_module in rpc_module_methods.iter() {
        res.push_str(&rpc_module.gen_methods_menu());
    }

    // generate type menu
    types.sort_by(|(name1, _), (name2, _)| name1.cmp(name2));
    res.push_str("* [RPC Types](#rpc-types)\n");
    for (name, _) in types.iter() {
        let ty = format!(
            "    * [Type `{}`](#type-{})\n",
            capitlize(name),
            name.to_lowercase()
        );
        res.push_str(&ty);
    }

    // generate methods content
    for rpc_module in rpc_module_methods.iter() {
        let content = format!("{}\n", rpc_module.gen_methods_content());
        res.push_str(&content);
    }

    // generate type content
    res.push_str("## RPC Types\n");
    gen_type_content(&mut res, types);

    fs::write(readme_path, res)?;
    Ok(())
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args: Vec<String> = std::env::args().collect();
    if args.len() > 1 {
        if args[1] == "--json" {
            return dump_openrpc_json();
        }
        gen_rpc_readme(&args[1])?;
    }
    Ok(())
}
